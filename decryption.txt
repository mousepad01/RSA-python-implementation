se citeste pe rand cheia privata si cheia publica din public_key.txt si private_key.txt

obtinem exponentul necesar pentru decriptare:
	
	e -> exponent de criptare, face parte din cheia publica
	n  = p * q, face parte din cheia publica
	p, q -> numere prime de >600 cifre ,formeaza cheia privata
	
	avem m ^ ((p - 1)(q - 1)) = 1 (mod n) (Th. Euler) =>
	     m ^ (k(p - 1)(q - 1)) = 1 (mod n) =>
	     m ^ (1 + k(p - 1)(q - 1)) = m (mod n) (1) 
	
	vrem exponentul de decriptare d, a.i. m ^ (ed) = m (mod n) (2)
	
	putem egala exponentii din (1), (2) => 1 + k(p - 1)(q - 1) = ed =>
					       ed + t(p - 1)(q - 1) = 1, t = -k (3)
	
	pentru (3), avem gcd(e, (p - 1)(q - 1) ) = 1 => t si d sunt coeficientii
	din identitatea lui Bezout, si pot fi calculati folosind algoritmul lui 
	Euclid, extins; algoritmul este adaptat pentru a returna doar d , intrucat t
	nu va fi folosit la nimic 

folosind exponentul d obtinut anterior, se realizeaza decriptarea:
	decrypted_packages[i] = crypted_packages[i] ^ d % n

se construieste la loc string ul corespunzator mesajului concatenand 
pachetele decriptate, si eliminand cifrele adaugate la inceput si final

se reconstruieste mesajul in final_decrypted si se retine in fisierul dfile.txt
